module BoolArray;

// BoolArray is a structure that represents a sequence of boolean values, storing each value in 1 bit.
type BoolArray = struct {
    buf: Array U64
};

namespace BoolArray {
    // Gets the size of the BoolArray.
    //
    // # Parameters
    // - `self` : The BoolArray instance.
    get_size : BoolArray -> I64;
    get_size = |self| (
        self.@buf.get_size * 64_I64
    );

    // Creates a new BoolArray.
    // 
    // # Parameters
    // - `size` : The size of the BoolArray in bits. It will be rounded up to the nearest multiple of 64.
    make : I64 -> BoolArray;
    make = |size| (
        let buf_size = (size + 63) / 64;
        BoolArray { buf: Array::fill(buf_size, 0_U64) }
    );

    // Fills the specified BoolArray with true values.
    //
    // # Parameters
    // - `self` : The target BoolArray
    fill_true : BoolArray -> BoolArray;
    fill_true = |self| (
        let buf = self.@buf;
        let buf = Iterator::range(0, buf.get_size).fold(buf, |i, buf|
            buf.set(i, 0xFFFFFFFFFFFFFFFF_U64)
        );
        BoolArray { buf: buf }
    );

    // Sets the bit at the specified index.
    // 
    // # Parameters
    // - `index` : The index of the bit to set
    // - `value` : The value to set (true or false)
    // - `self` : The target BoolArray
    set : I64 -> Bool -> BoolArray -> BoolArray;
    set = |index, value, self| (
        let buf = self.@buf;
        let buf_index = index / 64;
        let bit_index = index % 64;
        let flags = buf.@(buf_index);
        let mask = 1_U64.shift_left(bit_index.to_U64);
        let flags = if value {
            flags.bit_or(mask)
        } else {
            flags.bit_and(mask.bit_not)
        };
        let buf = buf.set(buf_index, flags);
        BoolArray { buf: buf }
    );

    // Gets the bit at the specified index.
    // 
    // # Parameters
    // - `index` : The index of the bit to get
    // - `self` : The target BoolArray
    @ : I64 -> BoolArray -> Bool;
    @ = |index, self| (
        let buf_index = index / 64;
        let bit_index = index % 64;
        let flags = self.@buf.@(buf_index);
        let mask = 1_U64.shift_left(bit_index.to_U64);
        flags.bit_and(mask) != 0_U64
    );
}